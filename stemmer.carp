(Project.config "title" "program") 
(Project.config "cflag" "-I.") 

(use String)
(use Array)

(load "https://veitheller.de/git/carpentry/inline-c@0.0.3")

(inline-c "
String String_replace_from_(const String* s, int n, String* s2) {
  int first_len = strlen(*s);
  int first_sub_len;

  if (n < 0) {
    first_sub_len = first_len + n;
  } else {
    first_sub_len = n;
  }

  if (first_sub_len < 1 || first_sub_len >= first_len) {
    return String_copy(s2);
  }

  int len = first_sub_len + strlen(*s2) + 1;
  String res = (String)CARP_MALLOC(len);
  memset(res, '\0', len);

  strncpy(res, *s, first_sub_len);
  strcat(res, *s2);

  return res;
}

String String_trim_from_(const String* s, int n) {
  String r = String_empty();
  String res = String_replace_from_(s, n, &r);
  CARP_FREE(r);
  return res;
}

String String_to_lower_(const String* p) {
  String r = String_copy(p);
  int i = strlen(r);
  while (i--) *(r + i) = tolower(*(r + i));
  return r;
}
")

(register replace-from (Fn [&String Int &String] String) "String_replace_from_")

(register trim-from (Fn [&String Int] String) "String_trim_from_")

(register to-lower (Fn [&String] String) "String_to_lower_")

(defn consonant? [x i]
  (let [char (char-at x i)]
    (case char
      \a false
      \e false
      \i false
      \o false
      \u false
      \y (or (= i 0) (consonant? x (- i 1)))
      true)))

(defn cv-form [x]
  (let-do [form [] prev \X]
    (for [i 0 (String.length x)]
      (do (cond (consonant? x i)
        (when (or (= prev \X) (= prev \V))
            (push-back! &form \C))
        (when (or (= prev \X) (= prev \C))
            (push-back! &form \V)))
        (set! prev (unsafe-last &form))))
    form))

(defn m [x]
  (let-do [n 0 form (cv-form x)]
    (for [i 0 (Int.dec (length &form))]
        (when (and
          (= \V @(unsafe-nth &form i))
          (= \C @(unsafe-nth &form (Int.inc i))))
            (set! n (Int.inc n))))
    n))

(defn contains-vowel? [x] 
  (let-do [res false]
    (for [i 0 (length x)]
      (when (not (consonant? x i))
        (do (set! res true) (break))))
    res))

(defn double-consonant? [x] 
  (let [j (Int.dec (String.length x))]
    (and*
      (>= j 1)
      (= (char-at x j) (char-at x (Int.dec j)))
      (consonant? x j))))

(defn cvc? [x] 
  (let [j (Int.dec (String.length x))]
    (and*
      (>= j 2)
      (consonant? x j)
      (not (consonant? x (- j 1)))
      (and (consonant? x (- j 2))
        (and*
            (not (= \w (char-at x j)))
            (not (= \x (char-at x j)))
            (not (= \y (char-at x j))))))))

(defn step-1a [x]
  (cond
    (not (ends-with? &x "s")) x
    (ends-with? &x "sses") (trim-from &x -2)
    (ends-with? &x "ies") (trim-from &x -2)
    (not (ends-with? &x "ss")) (trim-from &x -1)
  x))

(defn step-1bi [x]
  (cond
    (or*
      (ends-with? &x "at")
      (ends-with? &x "bl")
      (ends-with? &x "iz"))
        (replace-from &x 0 "e")
    (and*
      (double-consonant? &x)
      (not (ends-with? &x "l"))
      (not (ends-with? &x "s"))
      (not (ends-with? &x "z")))
        (trim-from &x -1)
    (and (= (m &x) 1) (cvc? &x))
      (replace-from &x 0 "e")
  x))

(defn step-1b [x]
  (cond (and (ends-with? &x "eed") (> (m &x) 0)) (trim-from &x -1)
  (let [v (contains-vowel? &x)]
    (cond
      (and v (ends-with? &x "ed")) (step-1bi (trim-from &x -2))
      (and v (ends-with? &x "ing")) (step-1bi (trim-from &x -3))
  x))))

(defn step-1c [x]
  (cond (and (ends-with? &x "y") (contains-vowel? &x))
    (replace-from &x -1 "i")
  x))

(defn step-2 [x]
  (let [m0 (> (m &x) 0)]
  (case (char-at &x (- (length &x) 2))
    \a (cond (and m0 (ends-with? &x "ational")) (replace-from &x -7 "ate")
             (and m0 (ends-with? &x "tional")) (replace-from &x -6 "tion")
        x)
    \c (cond (and m0 (ends-with? &x "enci")) (replace-from &x -4 "ence")
             (and m0 (ends-with? &x "anci")) (replace-from &x -4 "ance")
        x)
    \e (cond (and m0 (ends-with? &x "izer")) (replace-from &x -4 "ize")
        x)
    \l (cond (and m0 (ends-with? &x "bli")) (replace-from &x -3 "ble")
             (and m0 (ends-with? &x "alli")) (replace-from &x -4 "al")
             (and m0 (ends-with? &x "entli")) (replace-from &x -5 "ent")
             (and m0 (ends-with? &x "eli")) (replace-from &x -3 "e")
             (and m0 (ends-with? &x "ousli")) (replace-from &x -5 "ous")
        x)
    \o (cond (and m0 (ends-with? &x "ization")) (replace-from &x -7 "ize")
             (and m0 (ends-with? &x "ation")) (replace-from &x -5 "ate")
             (and m0 (ends-with? &x "ator")) (replace-from &x -4 "ate")
        x)
    \s (cond (and m0 (ends-with? &x "alism")) (replace-from &x -5 "al")
             (and m0 (ends-with? &x "iveness")) (replace-from &x -7 "ive")
             (and m0 (ends-with? &x "fulness")) (replace-from &x -7 "ful")
             (and m0 (ends-with? &x "ousness")) (replace-from &x -7 "ous")
        x)
    \t (cond (and m0 (ends-with? &x "aliti")) (replace-from &x -5 "al")
             (and m0 (ends-with? &x "iviti")) (replace-from &x -5 "ive")
             (and m0 (ends-with? &x "biliti")) (replace-from &x -6 "ble")
        x)
    \g (cond (and m0 (ends-with? &x "logi")) (replace-from &x -4 "log")
        x)
    x)))

(defn step-3 [x]
  (let [m0 (> (m &x) 0)]
  (case (char-at &x (- (length &x) 1))
    \e (cond (and m0 (ends-with? &x "icate")) (replace-from &x -5 "ic")
             (and m0 (ends-with? &x "ative")) (replace-from &x -5 "")
             (and m0 (ends-with? &x "alize")) (replace-from &x -5 "al")
        x)
    \i (cond (and m0 (ends-with? &x "iciti")) (replace-from &x -5 "ic")
        x)
    \l (cond (and m0 (ends-with? &x "ical")) (replace-from &x -4 "ic")
             (and m0 (ends-with? &x "ful")) (replace-from &x -3 "")
        x)
    \s (cond (and m0 (ends-with? &x "ness")) (replace-from &x -4 "")
        x)
    x)))

(defn step-4 [x]
  (let [m1 (> (m &x) 1)]
  (case (char-at &x (- (length &x) 2))
    \a (cond (and m1 (ends-with? &x "al")) (trim-from &x -2)
        x)
    \c (cond (and m1 (ends-with? &x "ance")) (trim-from &x -2)
             (and m1 (ends-with? &x "ence")) (trim-from &x -4)
        x)
    \i (cond (and m1 (ends-with? &x "ic")) (trim-from &x -2)
        x)
    \l (cond (and m1 (ends-with? &x "able")) (trim-from &x -4)
             (and m1 (ends-with? &x "ible")) (trim-from &x -4)
        x)
    \n (cond (and m1 (ends-with? &x "ant")) (trim-from &x -3)
             (and m1 (ends-with? &x "ement")) (trim-from &x -5)
             (and m1 (ends-with? &x "ment")) (trim-from &x -4)
             (and m1 (ends-with? &x "ent")) (trim-from &x -3)
        x)
    \o (cond (and (and m1 (ends-with? &x "ion"))
              (or
                (= \s (char-at &x (Int.dec (length &x))))
                (= \t (char-at &x (Int.dec (length &x))))))
              (trim-from &x -3)
              (and m1 (ends-with? &x "ou")) (trim-from &x -2)
        x)
    \s (cond (and m1 (ends-with? &x "ism")) (trim-from &x -3)
        x)
    \t (cond (and m1 (ends-with? &x "ate")) (trim-from &x -3)
             (and m1 (ends-with? &x "iti")) (trim-from &x -3)
        x)
    \u (cond (and m1 (ends-with? &x "ous")) (trim-from &x -3)
        x)
    \v (cond (and m1 (ends-with? &x "ive")) (trim-from &x -3)
        x)
    \z (cond (and m1 (ends-with? &x "ize")) (trim-from &x -3)
        x)
    x)))

(defn step-5a [x]
  (cond (ends-with? &x "e")
    (let [mn (m &x)]
      (cond
        (> mn 1) (trim-from &x -1)
        (and (= mn 1) (not (cvc? &(trim-from &x -1)))) (trim-from &x -1)
      x))
  x))

(defn step-5b [x]
  (cond
    (and*
      (ends-with? &x "l")
      (> (m &x) 1)
      (double-consonant? &x))
        (trim-from &x -1)
  x))


(defn stem [x]
  (let [xx (to-lower &x)]
  (cond (< (length &xx) 3)
    xx
    (=> xx
      (step-1a)
      (step-1b)
      (step-1c)
      (step-2)
      (step-3)
      (step-4)
      (step-5a)
      ;(step-5b)
))))

(defn stem-cstr [x]
  (let [xx (from-cstr x)]
    (cstr &(stem xx))))
  
(defn-do main []
  (IO.println &(stem @"vileness"))
0)


